using FrigidRogue.MonoGame.Core.Extensions;
using GoRogue.MapGeneration;
using GoRogue.MapGeneration.ContextComponents;
using GoRogue.Random;
using NGenerics.DataStructures.General;
using SadRogue.Primitives;
using SadRogue.Primitives.GridViews;
using ShaiRandom.Generators;
using Point = SadRogue.Primitives.Point;
using Rectangle = SadRogue.Primitives.Rectangle;

namespace MarsUndiscovered.Components.GenerationSteps
{
    public class MineWorkerGeneration : GenerationStep
    {
        /// <summary>
        /// Optional tag that must be associated with the component used to set wall/floor status of tiles changed by this
        /// algorithm.
        /// </summary>
        public readonly string WallFloorComponentTag;
        
        /// <summary>
        /// Optional tag that must be associated with the component used to store tunnels generated by this algorithm.
        /// </summary>
        public readonly string TunnelsComponentTag;

        public int MinVeinRandomEndpoints { get; set; } = 1;
        public int MaxVeinRandomEndpoints { get; set; } = 8;
        public bool AllowMoreEndpointsToIncreaseMapCoverage { get; set; } = true;
        
        /// <summary>
        /// RNG to use for maze generation.
        /// </summary>
        public IEnhancedRandom RNG { get; set; } = GlobalRandom.DefaultRNG;

        /// <summary>
        /// Creates a new mine worker generation step which simulates veins that have been mined out
        /// </summary>
        /// <param name="name">The name of the generation step.  Defaults to <see cref="MineWorker" />.</param>
        /// <param name="wallFloorComponentTag">
        /// Optional tag that must be associated with the map view component used to store/set
        /// floor/wall status.  Defaults to "WallFloor".
        /// </param>
        public MineWorkerGeneration(string name = null, string tunnelsComponentTag = "Tunnels", string wallFloorComponentTag = "WallFloor")
            : base(name)
        {
            TunnelsComponentTag = tunnelsComponentTag;
            WallFloorComponentTag = wallFloorComponentTag;
        }

        /// <inheritdoc/>
        protected override IEnumerator<object> OnPerform(GenerationContext context)
        {
            var wallFloorContext = context.GetFirstOrNew<ISettableGridView<bool>>(
                () => new ArrayView<bool>(context.Width, context.Height),
                WallFloorComponentTag
            );
            
            // Get or create/add a tunnel list context component
            var tunnelList = context.GetFirstOrNew(
                () => new ItemList<Area>(),
                TunnelsComponentTag
            );

            var veinPoints = GetVeinPoints();

            foreach (var veinPoint in veinPoints)
            {
                wallFloorContext[veinPoint] = true;
            }
            
            yield return null;

            if (AllowMoreEndpointsToIncreaseMapCoverage)
            {
                var additionalVeinPoints = GetAdditionalVeinPoints(veinPoints);

                foreach (var additionalVeinPoint in additionalVeinPoints)
                {
                    veinPoints.Add(additionalVeinPoint);
                    wallFloorContext[additionalVeinPoint] = true;
                }
            }
            
            yield return null;

            var graph = GenerateGraph(veinPoints);
            
            DigTunnel(graph, wallFloorContext);

            foreach (var edge in graph.Edges)
            {
                tunnelList.Add((Area)edge.Tag, Name);
            }
            
            yield return null;
        }

        private void DigTunnel(Graph<Point> graph, ISettableGridView<bool> wallFloorContext)
        {
            foreach (var edge in graph.Edges)
            {
                var tunnel = new Area();

                var direction = Direction.GetDirection(edge.FromVertex.Data, edge.ToVertex.Data);
                var nextPoint = edge.FromVertex.Data + direction;

                while (direction != Direction.None)
                {
                    var points = nextPoint.PointsOutwardsFrom(1, 1, MarsMap.MapWidth - 2, 1, MarsMap.MapHeight - 2);

                    foreach (var point in points)
                    {
                        tunnel.Add(point);
                        tunnel.Add(nextPoint);

                        wallFloorContext[point] = true;
                        wallFloorContext[nextPoint] = true;
                    }

                    direction = Direction.GetDirection(nextPoint, edge.ToVertex.Data);
                    nextPoint += direction;
                }

                edge.Tag = tunnel;
            }
        }

        private Graph<Point> GenerateGraph(List<Point> veinPoints)
        {
            var graph = new Graph<Point>(false);

            foreach (var vertex in veinPoints)
            {
                graph.AddVertex(vertex);
            }

            var unconsumedVertices = graph.Vertices.ToList();
            var consumedVertices = new List<Vertex<Point>>(graph.Vertices.Count);

            foreach (var vertex in graph.Vertices)
            {
                unconsumedVertices.Remove(vertex);
                
                if (consumedVertices.Count > 0)
                {
                    var edgeVertex = RNG.RandomElement(consumedVertices);
                    graph.AddEdge(vertex, edgeVertex);
                }
                
                consumedVertices.Add(vertex);
            }
            
            return graph;
        }

        private List<Point> GetAdditionalVeinPoints(List<Point> veinPoints)
        {
            var additionalVeinPoints = new List<Point>();

            var mapSegments = BreakIntoSegments(new Rectangle(1, 1, MarsMap.MapWidth - 1, MarsMap.MapHeight - 1));
            mapSegments = mapSegments.SelectMany(BreakIntoSegments).ToList();

            foreach (var segment in mapSegments)
            {
                if (!veinPoints.Any(p => segment.Contains(p)))
                {
                    var newPoint = new Point(RNG.NextInt(segment.MinExtentX, segment.MaxExtentX),
                        RNG.NextInt(segment.MinExtentY, segment.MaxExtentY));
                    additionalVeinPoints.Add(newPoint);
                }
            }

            return additionalVeinPoints;
        }

        private static List<Rectangle> BreakIntoSegments(Rectangle rectangle)
        {
            var mapSegments = new List<Rectangle>(4);

            var halfWidth = rectangle.Width / 2;
            var halfHeight = rectangle.Height / 2;
            var trailingWidth = rectangle.Width - halfWidth;
            var trailingHeight = rectangle.Height - halfHeight;

            mapSegments.Add(new Rectangle(rectangle.X, rectangle.Y, halfWidth, halfHeight));
            mapSegments.Add(new Rectangle(rectangle.X + halfWidth, rectangle.Y + halfHeight, trailingWidth, trailingHeight));
            mapSegments.Add(new Rectangle(rectangle.X + halfWidth, rectangle.Y, trailingWidth, halfHeight));
            mapSegments.Add(new Rectangle(rectangle.X, rectangle.Y + halfHeight, halfWidth, trailingHeight));
            
            return mapSegments;
        }

        private List<Point> GetVeinPoints()
        {
            var numVeinEndpoints = RNG.NextInt(MinVeinRandomEndpoints, MaxVeinRandomEndpoints);

            var veinPoints = new List<Point>(numVeinEndpoints);

            for (var i = 0; i < numVeinEndpoints; i++)
            {
                var newPoint = new Point(RNG.NextInt(1, MarsMap.MapWidth - 1), RNG.NextInt(1, MarsMap.MapHeight - 1));
                veinPoints.Add(newPoint);
            }

            return veinPoints;
        }
    }
}
